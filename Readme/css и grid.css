.container {
	max-width: 1170px;/*ширина сетки*/
	margin: 0 auto;/*выравнивает контейнер*/
	padding: 0 15px;/*за ранее выставлен отступ что бы не моб. технике не прилипало к краям*/
}

body {
	/*Хорошая практика если пробежаться по макету и определить среднее значения свойств которые можно указать
		в body и в дальнейшем в некоторых классах можно будет опустить запись переназначения дефолтных значений. 
		Так же в отдельных блоках если в дочерних элементах повторяются свойства можно задать родителю
	*/
	font-size: 16px;
	font-weight: bold;
	line-height: 18px;/*расстояние между строками Иногда можно этим свойством сделать отступы с верху снизу для строки*/
	letter-spacing: 0.25px;/*расстояние между буквами*/

	/*
      Единица fr(фракции) 3fr 1fr 1fr. При общей ширине в 100px
      1я колонка будет занимать 3fr из 5 возможных
      100 / 3+1+1 = 20px (1fr) значит 60px 1я колонка
   */
	/*----ПОЛЕЗНЫЕ СВОЙСТВА И ФУНКЦИИ----*/
	/*
   	repeat(кол-во раз, размер); повторить 
    repeat( 2, 50px ); - 50px 50px   
    repeat( 2, 50px 70px ); - 50px 70px 50px 70px*/

	/*Grid свойства и методы*/
	/*
   auto-fill - автоматическое заполнение элементами (заданного размера) пока есть место в контейнере 
                работает как flex-wrap: wrap.Если minmax(100px, 200px) и статичные размеры auto-fill умещает
                только по max значению. Если задать max в единице fr minmax(100px, 1fr), то auto-fill умещает
                в минимальном размере и держит их в этом размере
               Если быть точней.
               Контейнер делиться на равные части заданного размера. 
                Сетка создаётся по факту (размера контейнера / на размер элемента). Если установлен minmax и его max значение 
                статическое, то сетка (размера контейнера / на макс размер элемента), если в единице fr:  minmax(100px, 1fr), 
                то сетка будет: (размера контейнера / на минимальное значение.) По мере уменьшения контейнера
                уничтожение лишних секций сетки. Как контейнер сталкивается с реальными элементами происходит перенос flex-wrap: wrap.
                элементы используют max значение 1fr до тех пор пока auto-fill делает перерасчёт (контейнер / на минимальное значение элемента)
                То есть если размер контейнера позволяет 2м элементам в минимальном размере находиться на одной линии flex-wrap: wrap 
                не произойдёт.
  
        
   auto-fit -  Визуально похоже что работает так же как auto-fill, до момента использования fr единице в minmax(100px, 1fr).
               На самом деле работает это так. Сетка создаётся по факту имеющихся элементов и их размеров. То есть
               (кол-во эл. * максимальный размер). При уменьшении если контейнер встречается с сеткой то сетка (размера контейнера / на макс размер элемента),
               Из за того что серка работает по факту кол-ва элементов то minmax(100px, 1fr) это сетка (контейнер /  max размер), а max 
               размер (контейнер / кол-во эл.) и того (контейнер / (контейнер / кол-во эл.))

               Всё что нужно вкратце знать: При использовании единицы fr в minmax(100px, 1fr),
                  auto-fill держит элементы в min значении, auto-fit в max значении.  У обоих flex-wrap: wrap срабатывает при min значении. 
            
   minmax() - При изменении размера контейнера, если элемент не влазит будет изменяется до минимального значения.
            используется для адаптива. Используя в связке с auto-fill, auto-fill будет пытаться умещать по максимальному размеру элемента
            будто минимально размера нет. auto-fit так же отработает. 
*/

	/**********ОПРЕДЕЛЕНИЕ СЕТКИ и ЕЁ РАЗМЕРОВ***********/

	grid-template-rows: repeat();
	/*кол-во строк и их высота*/
	grid-template-columns: 1fr 2fr;
	/* ко-во колонок и их высота*/
	grid-template: grid-template-rows / grid-template-columns;
	/*отвечает так же и за grid-template-areas*/
	grid-auto-rows: 100px;
	/*высота по ум. с колонкой тож самое*/


	grid-template-columns: repeat(auto-fit, minmax(0, max-content));
	justify-content: space-between;

	/*каждому дочернему элементу нужно дать имя*/
	grid-area: header;
	grid-area: main;
	grid-area: sidebar;
	grid-area: footer;

	grid-template-areas:
		/*визуальное составление сетки в род. блоке*/
		"header header"
		/* этот участок называется Шаблон области*/
		"main sidebar"
		"footer footer";
	/*как сказано выше сокращённая grid-template может так же + */
	grid-template:
		"header header"25px
		/*то есть grid-template-rows для каждого ряда */
		"main sidebar"30px "footer footer"40px / 50px;

	/*****МЕСТОПОЛОЖЕНИЕ******/
	grid-column-start: 1;
	/*откуда начать*/
	grid-column-end: 2;
	/*у начала какой колонки закончить*/
	grid-column: 1;
	/*т.к. занимает одну колонку то сократить запись можно так*/
	grid-column: 1 / 3;
	/*занимаем 2 колонки с 1 по начало 3й*/
	grid-column: 1 / -1;
	/*от качала и до самого конца. -1 это конец*/
	/*с row всё тож самое. Можно ещё короче, порядок: */
	/*grid-row-start / grid-column-start / grid-row-end /grid-column-end */
	grid-area: 1 / 1 / 4 / 2;
	/*
  Ключевое слово span - указывается для определения не откуда - докуда, а
  откуда и сколько или сколько и докуда. Комбинаций строк и колонок куча.
  */
	grid-column: 1 / span 3;
	/*с 1й и 3 колонки*/
	grid-column: span 3 / 4;
	/*3 колонки до начала 3й*/

	/*
  Так же можно считать строки с конца использовав отрицательные значения. 
  Но мне пожалуй такое не нужно
  */


	/******ЗАЗОРЫ*******/
	grid-column-gap: 20px;
	/*расстояния солонок*/
	grid-row-gap: 20px;
	/*расстояния строк*/
	grid-gap: 20px 30px;
	/*grid-row-gap grid-column-gap*/
	grid-gap: 20px;
	/*общее расстояния*/





}
/*Просто описание свойств*/
:root {
	outline: none;
	/*стандартное выделение*/
	box-shadow: 0 0 10px 20px black;	/*оказывается есть необязательный параметр толщины 20px */
	overflow: scroll;

	/*Для таблиц*/
	display: inline-table; 
  display: table-cell; /*присваивает тип ячейки таблицы*/
}

/*
Селекторы_отношений
X > Y (родитель > дети) предназначен для выбора элементов, определяемым селектором Y непосредственно 
       расположенных в элементе, определяемым селектором X.

input + label выберет все элементы label, которые расположены сразу же за элементом input, 
         и являющиеся друг по отношению к другу соседями (сиблингами).
p ~ span выберет все элементы span, расположенные после элемента p на том же 
         уровне вложенности.

Вроде input не содержит ::after и ::before поэтому заворачивают в div
*/

.myClass:not(:first-child) {
	/*скрыть всех кроме 1 элемента*/
	display: none;
	float: left;
	/* Блок вылазит на поверхность, и становиться инлайновым это почти position: absolute, но со своими особенностями.
                  Следующий после его блок займёт его место, контент в том блоке будет обтекать этот блок будто они на одном уровне.
                  Перемещать блок можно в лева и в права.
                  */
	display: flow-root;
	clear: right;
	position: sticky;
	overflow: hidden;

}

/*При построение списков видел такой приём. Структура как обычно <li><a></a></li> Предположим a имеют border. li находятся
  плотно друг к другу и стили им не присваивали. Ссылки тоже будут плотно прижаты. Я бы делал разрыв примерно так*/
nav .li{ margin-right: 10px; }
nav .li:last-child{ margin-right: 0px; }
/*Вот видел такой прикол*/
nav .li + .li{ padding-left: 10px; }
/* 1. Блоки li остаются плотно но из-за того что нет стилей видимо и так сойдёт
	 2. Действительно как я раньше не допёр исключать таким образом 1й элемент от ненужного указания свойств
			Заменяет такую запись 
			nav li:nth-child(1n + 2){ padding-left: 10px; }
			(an + b), где a и b целые числа, n — счетчик, который автоматически принимает значение 0, 1, 2.
*/

/*При наведении за ранее зарезервировать border*/
nav .li a{ border: 1px solid transparent; }
nav .li a:hover{ border: 1px solid rebeccapurple; }





textarea {
	resize: none;
	/*убирает возможность изменять размер*/
	padding: 10px;
	/* не забывать делать отступы у */
	position: absolute;
	/*поднимает блок по z координате на 1 шаг. по ум привязывается к окну браузера */
}

/*####----<{ Заметки }>-----####*/
/* 
	Встретил баг в flex. Если один блок фиксированный, 2й блок нет и наполнен контентом под завязку,
	то 1й блок хоть и фиксированный он ужимается. Вариант или задать обычным способом размер нефиксированному блоку 
	или через flex-basis: 60%; так что бы не сжал фиксированный блок или выключить сжатие которое по ум. включено.
	flex-shrink: 0.

	При использовании position: absolute не забываем что элемент находиться на поверхности и 
	если предусмотрен контент на блоке над которым с позиционирован этот элемент, то нужно накидать 
	контента и проверить не будет ли контент залазить под этот элемент и сделать нужные padding отступы 
	контенту 
	 	
	Если задаётся float дочернему элементу, то родителю можно задать clear: both и вроде как блок не будет вылезать за родителя   
*/




