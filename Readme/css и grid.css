*{
	box-sizing: border-box;/*размер блоков внутри блока при 100% размере будут растягиваться до бордера родителя 
													 а не размером с родителя из-за которого правая граница и низ выходят за пределы потому  */
	box-sizing: content-box;
}

.container {/*container как правило задаёт только ширину. Высота зависит уже от контента*/
	max-width: 1170px;/*ширина сетки*/
	margin: 0 auto;/*выравнивает контейнер*/
	padding: 0 15px;/*за ранее выставлен отступ что бы не моб. технике не прилипало к краям*/
}

body {
	/*Хорошая практика если пробежаться по макету и определить среднее значения свойств которые можно указать
		в body и в дальнейшем в некоторых классах можно будет опустить запись переназначения дефолтных значений. 
		Так же в отдельных блоках если в дочерних элементах повторяются свойства можно задать родителю.

		Так же не мало важно определить одинаковые стили для каких-то элементов для которых можно создать один класс и 
		описывать его.
	*/
	font-size: 16px;
	font-weight: bold;
	line-height: 18px;/*расстояние между строками Иногда можно этим свойством сделать отступы с верху снизу для строки*/
	letter-spacing: 0.25px;/*расстояние между буквами*/
	border-width: 2px 5px 2px 2px;/*ручной контроль по кругу*/
	outline: 2px 5px 2px 2px;/*это по сути бордер над бордером*/
	position: relative;/*Не покидает родителя. В родителе может не быть размера, и установленный размер контента растянет родителя не смотря на relative */
	position: absolute;/* при absolute элементы становятся как бы  block .*/
	/*
		1. Если у родителя нет размеров, он зависит от размера дочерних элементов, то при использовании position: absolute или float 
				на дочерних элементах,родительский элемент потеряет размер т.к. элементы выпрыгивают наружу и находятся сами по себе
				со своим размером, но они могут позаимствовать родительский размер, но опять же только для себя.
		2. position: absolute ищет ближайший родительский блок со свойством position. В идеале должен встретить relative,
			 но если родитель так же absolute то привязывается к нему. Если у дочернего элемента
			 стоит размеры указанные в % то которые работают относительно родителя, то т.к. у родителя не указан размер (п.1)
			 то и в дочернем элементе % не от куда будет взяться.
		
	ИТОГ: везде где absolute и float мы не можем родителем опираться на размер дочерненго элемента. Родитель должен иметь свой габарит.
	Лучше всего минимизировать эти свойства что не переписывать кучу размеров под адаптив
	
  Предположим
   relative выше на более 1 блока от дочернего элемента с absolute. Задаю размеры там. Там где relative предполагаю 
   установить для дочернего эл. размер. Да я могу в дочернем элементе где-то там внизу далеко по уровню ссылаться на 
   родительский размер через %, но из-за того что но блоки стоящие перед блоком со свойством absolute будут свёрнуты,
   везде придётся делать или свой размер или ставить зависимость для каждого блока в %, что бы передать всем размер от родителя 
	 в px. И ещё т.к. блок с absolute старается привязаться к блоку со свойствам position и как было сказано он выпадает,
	 и если то в промежуточных блоках нет это свойства то установив в них бордеры видно что блоки находятся друг в друге и так как
	 блок с absolute не сними они отодвигают его от блока с relative.
	 В таком случае прописать всем absolute и блоки лягут друг в друга до родителя
	 

   ИТОГ: Я думаю нет необходимости привязывать блок absolute к блоку relative через несколько родительских блоков. 
         Как я и говорил что бы меньше писать адаптива проставляя кучу размеров нужно плясать от размера контента

	*/
	width: 100%; height: 100%;/*1й способ растянуть с absolute*/
	top: 0; left: 0; right: 0; bottom: 0;/*2й способ*/
	flex: 0 0 100%; /* Сокращённая запись: flex-grow, flex-shrink, flex-basis;*/
	width: 100%;/*Вроде как удобней задавать родителю в % что бы блок был резиновый. В px указывается непосредственно контенту 
							 Родителю указываются в px это min max размеры высоты и ширины что бы иметь хоть какие то рамки
							 Не мало важно что блок установленный на 100% ищет верх по структуре до ближайшего px размера 
							 */
	padding: 10px;/*display:flex выравнивание хорошо, но не даёт отступы. Не забываем ставить */
	margin: 0 auto;/*Не работает на inline и inline-block*/
	justify-content: center;/*Не заменяет свойство text-align т.к. свойство выравнивает контент с текстом, но текст
													 по прежнему прибит к левому краю. text-align: center решает эту задачу */
	float: left;
	/*Как работает float
		Не забываем что после установки свойства элемент выскакивает со всеми своими вложенностями на поверхность. 
		Если родитель держался только на этом блоке и так же родитель для какого-то элемента уже relative, то контент с 
		position: absolute тоже будет свёрнут т.к. он давно с наружи и держался.
	При использовании слайдера float лучше не использовать. Поведение не понятно.

	 У float поведение чем-то похоже на absolute, но со своими особенностями
	 Следующий после его блок займёт его место, контент в том блоке будет обтекать этот блок будто они на одном уровне.
   Перемещать блок можно в лева и в права. С лева - обтекает с права, с права - обтекает с лева.                            
	*/
	clear: right;/*Убирает обтекание*/
	/*
      Единица fr(фракции) 3fr 1fr 1fr. При общей ширине в 100px
      1я колонка будет занимать 3fr из 5 возможных
      100 / 3+1+1 = 20px (1fr) значит 60px 1я колонка
   */
	/*----ПОЛЕЗНЫЕ СВОЙСТВА И ФУНКЦИИ----*/
	/*
   	repeat(кол-во раз, размер); повторить 
    repeat( 2, 50px ); - 50px 50px   
    repeat( 2, 50px 70px ); - 50px 70px 50px 70px*/

	/*Grid свойства и методы*/
	/*
   auto-fill - автоматическое заполнение элементами (заданного размера) пока есть место в контейнере 
                работает как flex-wrap: wrap.Если minmax(100px, 200px) и статичные размеры auto-fill умещает
                только по max значению. Если задать max в единице fr minmax(100px, 1fr), то auto-fill умещает
                в минимальном размере и держит их в этом размере
               Если быть точней.
               Контейнер делиться на равные части заданного размера. 
                Сетка создаётся по факту (размера контейнера / на размер элемента). Если установлен minmax и его max значение 
                статическое, то сетка (размера контейнера / на макс размер элемента), если в единице fr:  minmax(100px, 1fr), 
                то сетка будет: (размера контейнера / на минимальное значение.) По мере уменьшения контейнера
                уничтожение лишних секций сетки. Как контейнер сталкивается с реальными элементами происходит перенос flex-wrap: wrap.
                элементы используют max значение 1fr до тех пор пока auto-fill делает перерасчёт (контейнер / на минимальное значение элемента)
                То есть если размер контейнера позволяет 2м элементам в минимальном размере находиться на одной линии flex-wrap: wrap 
                не произойдёт.
  
        
   auto-fit -  Визуально похоже что работает так же как auto-fill, до момента использования fr единице в minmax(100px, 1fr).
               На самом деле работает это так. Сетка создаётся по факту имеющихся элементов и их размеров. То есть
               (кол-во эл. * максимальный размер). При уменьшении если контейнер встречается с сеткой то сетка (размера контейнера / на макс размер элемента),
               Из за того что серка работает по факту кол-ва элементов то minmax(100px, 1fr) это сетка (контейнер /  max размер), а max 
               размер (контейнер / кол-во эл.) и того (контейнер / (контейнер / кол-во эл.))

               Всё что нужно вкратце знать: При использовании единицы fr в minmax(100px, 1fr),
                  auto-fill держит элементы в min значении, auto-fit в max значении.  У обоих flex-wrap: wrap срабатывает при min значении. 
            
   minmax() - При изменении размера контейнера, если элемент не влазит будет изменяется до минимального значения.
            используется для адаптива. Используя в связке с auto-fill, auto-fill будет пытаться умещать по максимальному размеру элемента
            будто минимально размера нет. auto-fit так же отработает. 
*/

	/**********ОПРЕДЕЛЕНИЕ СЕТКИ и ЕЁ РАЗМЕРОВ***********/

	grid-template-rows: repeat();
	/*кол-во строк и их высота*/
	grid-template-columns: 1fr 2fr;
	/* ко-во колонок и их высота*/
	grid-template: grid-template-rows / grid-template-columns;
	/*отвечает так же и за grid-template-areas*/
	grid-auto-rows: 100px;
	/*высота по ум. с колонкой тож самое*/


	grid-template-columns: repeat(auto-fit, minmax(0, max-content));
	justify-content: space-between;

	/*каждому дочернему элементу нужно дать имя*/
	grid-area: header;
	grid-area: main;
	grid-area: sidebar;
	grid-area: footer;

	grid-template-areas:
		/*визуальное составление сетки в род. блоке*/
		"header header"
		/* этот участок называется Шаблон области*/
		"main sidebar"
		"footer footer";
	/*как сказано выше сокращённая grid-template может так же + */
	grid-template:
		"header header"25px
		/*то есть grid-template-rows для каждого ряда */
		"main sidebar"30px "footer footer"40px / 50px;

	/*****МЕСТОПОЛОЖЕНИЕ******/
	grid-column-start: 1;
	/*откуда начать*/
	grid-column-end: 2;
	/*у начала какой колонки закончить*/
	grid-column: 1;
	/*т.к. занимает одну колонку то сократить запись можно так*/
	grid-column: 1 / 3;
	/*занимаем 2 колонки с 1 по начало 3й*/
	grid-column: 1 / -1;
	/*от качала и до самого конца. -1 это конец*/
	/*с row всё тож самое. Можно ещё короче, порядок: */
	/*grid-row-start / grid-column-start / grid-row-end /grid-column-end */
	grid-area: 1 / 1 / 4 / 2;
	/*
  Ключевое слово span - указывается для определения не откуда - докуда, а
  откуда и сколько или сколько и докуда. Комбинаций строк и колонок куча.
  */
	grid-column: 1 / span 3;
	/*с 1й и 3 колонки*/
	grid-column: span 3 / 4;
	/*3 колонки до начала 3й*/

	/*
  Так же можно считать строки с конца использовав отрицательные значения. 
  Но мне пожалуй такое не нужно
  */


	/******ЗАЗОРЫ*******/
	grid-column-gap: 20px;
	/*расстояния солонок*/
	grid-row-gap: 20px;
	/*расстояния строк*/
	grid-gap: 20px 30px;
	/*grid-row-gap grid-column-gap*/
	grid-gap: 20px;
	/*общее расстояния*/
}
/*Просто описание свойств*/
:root {
	outline: none;
	/*стандартное выделение*/
	box-shadow: 0 0 10px 20px black;	/*оказывается есть необязательный параметр толщины 20px */
	overflow: scroll;

	/*Для таблиц*/
	display: inline-table; 
  display: table-cell; /*присваивает тип ячейки таблицы*/
}
.parent .child{


	flex-basis: 50%;/*По ум. auto. Управляет размером блока. Сколько % должен занять блок в родительском блоке*/
	flex-grow: 1; /*По ум. 0. Растянется на всю оставшуюся ширину*/
	flex-shrink: 0;/* По ум. 1. Отвечает за автоматическое сжатие блока.. Можно min-width: max-content; или выключить сжатие flex-shrink: 0 */
}
button{
	font-size: 0;/**/
	width: 10px;
	height: 10px;
	border-radius: 50%;
}
/*
Селекторы_отношений
X > Y (родитель > дети) предназначен для выбора элементов, определяемым селектором Y непосредственно 
       расположенных в элементе, определяемым селектором X.

input + label выберет все элементы label, которые расположены сразу же за элементом input, 
         и являющиеся друг по отношению к другу соседями (сиблингами).
p ~ span выберет все элементы span, расположенные после элемента p на том же 
         уровне вложенности.

Вроде input не содержит ::after и ::before поэтому заворачивают в div
*/
.myClass:target {
	/*Отработает если была нажата где-то ссылка в атрибуте которой передан именно id
	блока у которого ещё и класс myClass. 
		<a href="#myId"></a>
		<div id="myId" class="myClass"></div>
		Что-то типа label для input
	*/

}
/*Вроде нужная штука при разработке модальных окон.  На заметку если неправильно привязать модальное окно,
	1. При закрытии окна если мы будем находиться внизу, окажемся снова на верху сайта. Привязывать нужно 
			к элементу который ходит за нами. (Header например) или зафиксировать пиксель 
	2. Что бы страница не перезагружалась в close ставят href="#" но при клике она будет в url
При таком подходе на css скролится задний контент и url заполняется не нужным хламом. Лучше делать на js.
Так же не забываем что организовать крестик можно через checkbox
*/
  

.myClass:not(:first-child) {
	/*скрыть всех кроме 1 элемента*/
	display: none;/*Переход none в какое либо состояние не анимируется свойством transition*/
	display: flow-root;
	
	position: sticky;
	overflow: hidden;
	transform: perspective();/*оказывается есть метод */
	
	/*Так же в свойство не будет работать если общему классу задать общее значение transform, а потом
		дочернему что-то езё дополнять указав снова это свойство
	*/
}




/*При построение списков видел такой приём. Структура как обычно <li><a></a></li> Предположим a имеют border. li находятся
  плотно друг к другу и стили им не присваивали. Ссылки тоже будут плотно прижаты. Я бы делал разрыв примерно так*/
nav .li{ margin-right: 10px; }
nav .li:last-child{ margin-right: 0px; }
/*Вот видел такой прикол*/
nav .li + .li{ padding-left: 10px; }
/* 1. Блоки li остаются плотно но из-за того что нет стилей видимо и так сойдёт
	 2. Действительно как я раньше не допёр исключать таким образом 1й элемент от ненужного указания свойств
			Заменяет такую запись 
			nav li:nth-child(1n + 2){ padding-left: 10px; }
			(an + b), где a и b целые числа, n — счетчик, который автоматически принимает значение 0, 1, 2.
*/

/*При наведении за ранее зарезервировать border*/
nav .li a{ border: 1px solid transparent; }
nav .li a:hover{ border: 1px solid rebeccapurple; }





textarea {
	resize: none;
	/*убирает возможность изменять размер*/
	padding: 10px;
	/* не забывать делать отступы у */
	position: absolute;
	/*поднимает блок по z координате на 1 шаг. по ум привязывается к окну браузера */
}

/*####----<{ Заметки }>-----####*/
/* 
	Встретил баг в flex. Если один блок фиксированный, 2й блок нет и наполнен контентом под завязку,
	то 1й блок хоть и фиксированный он ужимается. Вариант или задать обычным способом размер нефиксированному блоку 
	или растянуть через flex-basis: 60%; так что бы не сжал фиксированный блок или выключить сжатие которое по ум. включено.
	flex-shrink: 0.

	Ещё с flex выяснилась такая штука. По умолчанию дочерние элементы принимают форму самого высокого блока. Что бы
	убрать это состояние нужному дочернему присваивается align-self: baseline; или start
	

	При использовании position: absolute не забываем что элемент находиться на поверхности и 
	если предусмотрен контент на блоке над которым с позиционирован этот элемент, то нужно накидать 
	контента и проверить не будет ли контент залазить под этот элемент и сделать нужные padding отступы 
	контенту 
	 	
	Если задаётся float дочернему элементу, то родителю можно задать clear: both и вроде как блок не будет вылезать за родителя   
*/

/*########------<{ Практические казусы }>----------------------------------------------------------*/
/*БОЛЬШАЯ ОШИБКА делать так. Предположим у 2х элементов общий класс и отдельные свои классы.
<span class="slider__btn slider__btn--left"></span>
<span class="slider__btn slider__btn--right"></span>
Как НЕ СТОИТ делать
*/
.slider__btn::after,
.slider__btn::before{
  content: '';
  width: 10px;
	height: 10px;
	content: '';
  width: 10px;
  height: 10px;
  display: flex;
  justify-content: center;
  align-items: center;
}
.slider__btn--left::before {
	/*Ожидать что тут будет по середине. Квадрат будет смещён потому что рядом 2й квадрат от after тоже в 
		середине стоит скрытый */
  border: 1px solid #000;
 
}
/*Правильный вариант. Но за ранее скажу что делать стрелки из бордера потом переворачивать на 45 и 135 градусов, и пытаться выровнять
	через flex. Они не окажутся по середине, верней ось квадрата по середине как полагается когда мы разворачиваем получаем ромб и оставляем одну 
	из частей она остаётся на своей стороне часть ромба и нам надо что бы она уехала на середину со своей стороны.
	Вот как довольно точно выровнять. И делать нужно именно в таком раскладе. не правильная установка translate будет не так высчитывать
*/
.slider__btn {
  width: 50px;
  height: 60px;
 
  margin-left: 20px;
  border: 2px solid darkorchid;
  display: block;
  position: relative;
 
}
.slider__btn::before{
  content: '';
  --border: 3px;
  width: var(--sliderArrowSize);
  height: var(--sliderArrowSize);
  border-top: var(--border) solid #000;
  border-left: var(--border) solid #000;
  
  position: absolute;
  top: 50%;
  left: 50%; 
 
}
/*сдвиг на 4ю часть квадрата*/
.slider__btn--left::before {
  transform: translate(-25%, -50%) rotate(-45deg);
}
.slider__btn--right::before {
  transform: translate(-75%, -50%) rotate(-225deg);
}


/*-----------------------------------------------------------------------------------------------------------*/





